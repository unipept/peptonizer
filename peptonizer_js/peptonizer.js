import { loadPyodide } from "pyodide";

/**
 * Start the peptonizer. This function takes in a PSM-file that has been read in earlier (so no file paths here). The
 * PSMS including their intensities are then used as input to the Peptonizer-pipeline. This pipeline will finally
 * return a Map in which NCBI taxon IDs are mapped onto their propabilities (as computed by the Peptonizer).
 *
 * @param psmContent Content of a PSM-file generated by upstream tools (such as MS2Rescore).
 * @return Mapping between NCBI taxon IDs (integer, > 0) and probabilities (float in [0, 1]).
 */
export async function peptonize(psmContent) {
    let pyodide = await loadPyodide({indexURL: "https://cdn.jsdelivr.net/pyodide/v0.26.1/full"});

    pyodide.globals.set('input', psmContent);
    // Load all packages into the Pyodide runtime environment that are required by the Peptonizer
    await pyodide.loadPackage(
        [
            'numpy',
            'scipy',
            'networkx',
            'pandas',
            'micropip',
            'matplotlib',
            'requests',
            'sqlite3',
            'aiohttp',
            'openssl'
        ]);

    const data = await (await fetch("data/rescored_small.psms.tsv")).text();
    pyodide.globals.set('input', data);

    const peptonizerOutput = await pyodide.runPythonAsync(`
        import micropip
        
        await micropip.install("lib/peptonizer-0.1-py3-none-any.whl")
        await micropip.install("lib/ete3-3.1.3-py310-none-any.whl")
        await micropip.install("aiofiles")

        import peptonizer
       
        # The PSM input should be provided to the parser as a list of strings
        psms = [globals().get('input')]
        
        print("Started parsing pout file from MS2Rescore...")
        parsed_input = peptonizer.parse_ms2rescore_output(psms, 0.01)
        
        print()
        
        #peptonizer.pepgm.run_pepgm(graph_content, 0.9, 0.6, True, 0.5, 10000, 0.3)
    `);

    console.log(peptonizerOutput);

    return null;
}

